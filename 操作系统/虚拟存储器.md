# 虚拟存储器
![虚拟存储器](http://cdn.imkiwi.top/image/markdown/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8.png)

## 基础
### 局部性原理
- 程序在执行时，大部分指令是顺序执行的
- 过程调用的深度往往不超过5，程序在一段时间内都局限在这些过程的范围内运行
- 程序中的的循环结构虽然只包含少量的指令，但将被多次执行
- 程序对数据的处理往往都局限在很小的范围内
- 时间局限性：某条指令在执行后很可能不久之后再次被执行，原因是循环操作
- 空间局限性：程序访问了某个单元后，其附近的存储单元也在不久之后会被访问，原因是程序的顺序执行

### 定义
具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近内存，而成本又接近于外村。

### 特征
- 多次性：作业中的程序或数据无需一次性调入内存，而是在运行到尚未调入内存的那部分程序或需要使用未调入内存的数据时再将其调入内存。
- 对换性：作业中的程序和数据不需要一直再内存中常驻，允许在作业的运行过程中换进和换出。在进程的运行过程中，将不需要的数据和代码进行换入和换出。或将阻塞的进程调入外村，待其就绪后再调入内存。
- 虚拟性：从逻辑上扩大内存容量。使得小内存中运行大的作业。

### 实现方法
- 分页请求系统：用户程序只装入少量页面的程序和数据即可运行。之后通过调页功能和页面对换陆续将要使用的页面调入内存。
- 请求分段系统：允许用户程序只装入少数段的程序和数据即可启动运行，之后再通过调段功能和段的置换功能将暂时不能运行的段调出，再调入即将运行的段。

## 请求分页存储管理方式
### 基础
- 页表结构：页表项中除了包含页号和对应的物理块号以外，还包含下列的表项：    
  1. 状态位：表示该页是否已经调入内存
  2. 访问字段：记录该页在一段时间内被访问的次数，或记录有多长时间没被访问。
  3. 修改位：标识该页在调入内存后是否被修改过，若未被修改则在置换时不需要写回外存
  4. 外存地址：该页在外存上的地址

- 缺页中断：当需要访问的页面不在内存中时，产生缺页中断，由系统将所缺的页面调入内存。该中断与一般的中断有两个明显的区别如下：   
  1. 在指令执行期间产生和处理中断信号。
  2. 一条指令执行期间可能产生多次缺页中断。
- 地址变换
  首先检索快表，找出所要访问的页，若找到，便修改页表项中的访问位。若在快表中没有找到，则取内存中查找页表，再从找到的页表中判断该页是否在内存中，若不在，则将该页调入内存，并将该页写入快表。最后获得物理地址。

### 内存分配
#### 最小物理块数
每个进程持有的物理块越少，越容易产生缺页中断。最小物理块数指的进程能够运行所需要的最小物理块数。
#### 内存分配策略
- 固定分配局部置换     
  为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。在进程运行中如果发生缺页中断，则只能从分配给该进程的若干个页面中选择一个页面换出后再调入新的页面。
- 可变分配全局置换    
   先为每个进程分配一定数目的物理块，在进程运行期间根据情况做适当的增加或减少。全局置换是指当产生缺页中断后系统从所有的空闲物理块中取出一块分配给进程，并将页面置入物理块中。
- 可变分配局部置换     
  局部置换是指产生缺页中断时只在进程所属的物理块中进行置换。若系统频繁的发生缺页中断，则为进程分配新的物理块。
#### 内存分配算法
- 平均分配算法，将系统中所有可供分配的物理块平均分配给各个进程
- 按比例分配算法，根据进程的大小按比例分配物理块
- 优先权分配算法，将一部分物理块按比例分配给各进程，另一部分根据个进程的优先权进行分配，高优先级的进程可以分配到更多的物理块。
#### 页面调入
- 调入时间：   
  1. 预调入策略：将那些预计在不久之后便会被访问的页面预先调入内存
  2. 请求调页策略：进程在运行过程中发现需要访问的页不在内存中，便将该页调入内存
- 调入位置： 
  系统中外存分为两部分，分别是离散存储的文件区和连续存储的对换区。对换区的IO速度比文件区高。
  1. 系统拥有足够的对换区空间：首先将进程有关的页面从文件区拷贝到对换区，然后全部从对换区调入所需的页面
  2. 系统缺少足够的对换区空间：不会被修改的文件从文件区调入，可能修改的文件从对换区调入和调出
  3. UNIX方式：为运行过的页面从文件区调入，被换出的文件放在对换区，下次调入时从对换区调入
- 调入过程：    
  当程序要访问的页面不在内存时，便产生一次缺页中断。中断处理程序分析终端原因后转入缺页中断处理程序。该程序在查找到缺页所在的物理块后，若内存能容纳新页，则将缺页调入内存，若内存已满，则按照某种算法选择一页换出。再将缺页调入内存，同时将该页写入快表。
- 缺页率：   
  缺页率 = 访问页面失败次数 / （总访问次数）   
  影响因素：    
  1. 页面大小，页面越大，缺页率越低
  2. 进程分配的物理块数量，物理块越多，缺页率越低
  3. 页面置换算法
  4. 程序本身的特性
#### 页面置换算法
- 最佳置换算法：    
  被换出的页面是最长时间内不会被访问的页面，该算法不可能被实现。因为无法预知哪一个页面时最长时间内不被访问的页面
- FIFO（先进先出算法）：   
  该算法选择换出的页面是最早进入内存的页面。实现方法是将页面按照进入内存的顺序链接成一个队列，并设置一个指针指向最老的页面。
- LRU算法：     
  选择所有页面中最久未被访问的页面换出。实现方法是维护一个栈，每当进程访问一个页面，则将该页面出栈并压入栈顶。需要选择换出页面时则选择栈底的页面换出。
- LFU算法：    
  该算法选择一段时间内访问频率最小的页面进行换出
- CLOCK算法：    
  该算法将内存中的所有页面链接成一个循环队列，并为每一页设置一个访问位。当发生缺页中断时，按照FIFO算法进行遍历，若访问位为0，则选择该页进行换出，若访问页为1，则将访问位置0.当页被程序使用时，访问位被置1。
- 改进型CLOCK算法：     
  在该算法中，除了考虑该页的访问位，同时设置一个修改位，若被修改则置1。所以在内存中分为四种类型的页面如下：    
  1. 访问位：0，修改位：0  -- 最近既没有被访问，也没有被修改
  2. 访问位：0，修改位：1  -- 最近没有被访问，但是被修改
  3. 访问位：1，修改位：0  -- 最近被访问，但是没有被修改
  4. 访问位：1，修改位：1  -- 最近即被访问，也被修改    
   
  寻找换出页面时，首先寻找第一类页面，若没有找到，则在第二轮遍历中寻找第二类页面，同时在遍历过程中将所有页面的访问位置0。若仍没有找到，则重复第一次寻找。若还是没有找到，则再次重复第二轮寻找，此使一定能找到一个第二类的页面。
- PBA（页面缓冲算法）：    
  该算法显著降低了页面置换的频率，且不需要额外的硬件支持。算法需要在系统中维护两个链表，分别为：   
  1. 空闲页面链表：该链表将系统中所有的空闲物理块连接成一个链，在系统发生缺页中断时，取出链首的物理块分配给进程，以降低进程的缺页率。当有未被修改的页面换出时，则将该页挂在链尾。后续进程若需要使用该页，则直接从链表中取下即可。
  2. 修改页面链表：当进程需要将一个已经修改的页面换出时，将该页挂在链表的末尾。以减少IO磁盘的频率。
## 抖动和工作集
### 抖动
抖动是多道系统中进程数增加后系统的利用率逐渐趋近于0。
- 原因：进行过多，分配给进程的物理块太少。系统的大部分时间被消耗在页面的置换上。
- 预防方法：    
  1. 局部置换：只允许进程在分配给自己的物理块上进行页面置换。将抖动局限在进程自身，不会影响别的进程。
  2. 使用工作集：调度程序在作业调入内存前检查每个进程在内存驻留的页面是否足够多。若足够做，则调入作业。若有内存频繁发生缺页，则将物理块分配给该进程，不将作业调入内存。
  3. 使用“L=S”调节缺页率：L是缺页之间的平均时间，S是置换一个页面所需的平均时间。
  4. 暂停进程：进程过多，即将发生抖动时，暂停某些进程将其调入外存，将其物理块分配给别的进程。
### 工作集
某段时间间隔里，进程实际所需要访问的页面的集合。实际的工作集是指进程在某时刻，窗口大小内所访问的页面的集合。
## 请求分段存储管理
该存储管理方式和请求分页管理方式十分相似。只不过一个以页位单位，一个以段为单位。
### 基础
- 段表结构：除了页面中的六个字段外，还有存取方式字段和增补位。  
  1. 存取方式：标识该段的读写权限。
  2. 增补位：标识该段在运行过程中是否进行过动态增长。
- 缺段中断：在程序运行过程中发现需要使用的段不在内存，则产生中断将该段调入内存。 
### 共享段
在系统中设置一张共享段表。该表记录了共享段的基本信息和共享计数。
- 共享进程计数器：记录了使用该段的进程的数量。只有计数器位0时，该段才能被回收。
- 段号：对于一个共享段，每个进程可以拥有不同的段号。
#### 分配和回收
- 分配：第一个进程在使用共享段时，为该段分配一块内存区域，并在段表中记录该段的基本信息，同时记录该进程的编号，将计数器加一。之后每有一个进程，计数器都加一，且在段表中添加一行进程信息。
- 回收：进程不需要该段时，将计数器减一，并删除段表中该进程所在的行。当计数器为0时表示该段所占有的物理内存可以被回收。
