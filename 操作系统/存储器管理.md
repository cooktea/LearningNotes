# 存储器管理
![框架](http://cdn.imkiwi.top/image/markdown/%E5%AD%98%E5%82%A8%E5%99%A8.png)
- [存储器管理](#%e5%ad%98%e5%82%a8%e5%99%a8%e7%ae%a1%e7%90%86)
  - [概述](#%e6%a6%82%e8%bf%b0)
    - [存储器结构](#%e5%ad%98%e5%82%a8%e5%99%a8%e7%bb%93%e6%9e%84)
    - [程序的装入和链接](#%e7%a8%8b%e5%ba%8f%e7%9a%84%e8%a3%85%e5%85%a5%e5%92%8c%e9%93%be%e6%8e%a5)
      - [装入](#%e8%a3%85%e5%85%a5)
      - [链接](#%e9%93%be%e6%8e%a5)
  - [连续分配](#%e8%bf%9e%e7%bb%ad%e5%88%86%e9%85%8d)
    - [单一连续分配](#%e5%8d%95%e4%b8%80%e8%bf%9e%e7%bb%ad%e5%88%86%e9%85%8d)
    - [固定分区分配](#%e5%9b%ba%e5%ae%9a%e5%88%86%e5%8c%ba%e5%88%86%e9%85%8d)
    - [动态分区分配](#%e5%8a%a8%e6%80%81%e5%88%86%e5%8c%ba%e5%88%86%e9%85%8d)
    - [动态分区分配的分配算法](#%e5%8a%a8%e6%80%81%e5%88%86%e5%8c%ba%e5%88%86%e9%85%8d%e7%9a%84%e5%88%86%e9%85%8d%e7%ae%97%e6%b3%95)
      - [顺序搜索动态分区分配](#%e9%a1%ba%e5%ba%8f%e6%90%9c%e7%b4%a2%e5%8a%a8%e6%80%81%e5%88%86%e5%8c%ba%e5%88%86%e9%85%8d)
      - [索引搜索动态分区分配](#%e7%b4%a2%e5%bc%95%e6%90%9c%e7%b4%a2%e5%8a%a8%e6%80%81%e5%88%86%e5%8c%ba%e5%88%86%e9%85%8d)
      - [动态可重定位分区分配](#%e5%8a%a8%e6%80%81%e5%8f%af%e9%87%8d%e5%ae%9a%e4%bd%8d%e5%88%86%e5%8c%ba%e5%88%86%e9%85%8d)
  - [对换](#%e5%af%b9%e6%8d%a2)
    - [对换类型](#%e5%af%b9%e6%8d%a2%e7%b1%bb%e5%9e%8b)
    - [进程对换](#%e8%bf%9b%e7%a8%8b%e5%af%b9%e6%8d%a2)
  - [分页存储管理](#%e5%88%86%e9%a1%b5%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86)
    - [基础](#%e5%9f%ba%e7%a1%80)
    - [地址变换](#%e5%9c%b0%e5%9d%80%e5%8f%98%e6%8d%a2)
      - [基本结构](#%e5%9f%ba%e6%9c%ac%e7%bb%93%e6%9e%84)
      - [快表](#%e5%bf%ab%e8%a1%a8)
    - [访问内存的有效时间](#%e8%ae%bf%e9%97%ae%e5%86%85%e5%ad%98%e7%9a%84%e6%9c%89%e6%95%88%e6%97%b6%e9%97%b4)
    - [多级页表](#%e5%a4%9a%e7%ba%a7%e9%a1%b5%e8%a1%a8)
    - [反置页表](#%e5%8f%8d%e7%bd%ae%e9%a1%b5%e8%a1%a8)
  - [分段存储管理](#%e5%88%86%e6%ae%b5%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86)
    - [作用](#%e4%bd%9c%e7%94%a8)
    - [原理](#%e5%8e%9f%e7%90%86)
    - [分段和分页的区别](#%e5%88%86%e6%ae%b5%e5%92%8c%e5%88%86%e9%a1%b5%e7%9a%84%e5%8c%ba%e5%88%ab)
  - [段页式存储管理](#%e6%ae%b5%e9%a1%b5%e5%bc%8f%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86)
    - [基本原理](#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86)
    - [地址变换](#%e5%9c%b0%e5%9d%80%e5%8f%98%e6%8d%a2-1)

## 概述
### 存储器结构
计算机系统中的存储器一般而言至少有三级，最高层为CPU寄存器，中间层为贮存，最底层为辅存。   
![存储器结构](http://cdn.imkiwi.top/1568512544.969406.jpg)
- 主存储器   
  主存储器用于保存进程运行时的程序和数据，也成为可执行存储器。处理机通常从主存中获取指令和数据分别放入指令寄存器和数据寄存器。或反之将寄存器中的内容写入主存。主存的访问速度远低于CPU的指令执行速度。
- 寄存器     
  寄存器的访问速度和CPU指令执行速度相当，但价格十分昂贵。
- 高速缓存   
  高速缓存介于寄存器和主存之间，主要作用是备份主存中的常用数据，减少处理机对主存的访问次数。高速缓存的作用主要基于程序的局部性原理。
- 磁盘缓存   
  由于磁盘的IO速度远低于对主存的访问速度，所以设置了磁盘缓存用于暂存频繁使用的一部分磁盘数据和信息，用于减少访问磁盘的速度。磁盘缓存时在主存中划分一部分存储空间暂存从磁盘中读出或写入的信息。

### 程序的装入和链接
程序在系统中运行时必须先将其装入内存，再转变为一个可以执行的程序。其步骤如下：   
1. 编译：由编译程序对源程序进行编译，形成若干个目标模块。
2. 链接：由链接程序将编译后形成的一组目标模块以及它们需要的库函数链接在一起，形成一个完整的装入模块。
3. 装入：由装入程序将装入模块装入内存。
#### 装入
- 绝对装入方式    
  程序经编译后将产生由绝对地址（物理地址）的目标代码。当计算机系统很小且只能运行单道程序时，系统将直到该程序的目标代码在内存中的驻留位置。此时采用绝对装入方式时，程序中的相对地址（逻辑地址）和实际的内存地址相同，所以不再需要对地址进行修改。
- 可重定位装入方式    
  在多道程序环境下，编译程序不会预知编译后得到的目标模块在内存中的贮存位置，所以目标模块的起始地址通常都为0。由于可重定位装入后程序内的逻辑地址和物理地址不再相同，所以需要对逻辑地址进行重定位。假设程序装入的物理地址为10000，而程序中需要对2500地址进行操作，则实际的操作地址应该是12500。对于程序中的逻辑地址修改在装入时进行，即装入后的程序中的逻辑地址已经变成了实际的物理地址。
- 动态运行时的装入方式    
  在具有对换功能的系统中，由于会在程序装入后改变其位置，所以在装入时修改逻辑地址不再合适。动态装入方式则是在程序运行的过程中变换逻辑地址。该装入方式需要一个重定位寄存器的支持。
#### 链接
- 静态链接   
  将各目标模块以及所需要的库链接成一个完整的装配模块，以后不再拆开。    
  需要解决的问题：   
  1. 相对地址需要进行修改
  2. 变换外部调用符号
- 装入时动态链接   
  用户源程序编译后得到的一组目标模块在装入内存时采用边装入边链接的方式。   
  优点：   
  1. 便于修改和更新
  2. 便于实现对目标模块的共享
- 运行时动态链接   
  将某些模块的链接推迟到程序运行时再进行。即当程序运行时发现一个被调用的模块尚未装入内存时，由操作系统去找到该模块并装入内存中。可以加快程序的装入速度并节省大量的内存空间。
## 连续分配
### 单一连续分配
整个内存的用户空间由程序独占，且内存中只装有一道程序。
### 固定分区分配
将用户空间划分为若干个固定大小的区域，每个区域中只装入一道作业。
- 划分分区的方法：   
  1. 分区大小相等
  2. 分区大小不等
- 内存分配：   
  将分区按照大小进行排队，并建立一张分区使用表。表中包含各分区的起始地址、大小、状态等。当有程序需要装入时，检索该表并分配一个分区给程序装入。如果检索不到则拒绝分配。
### 动态分区分配
根据进程的实际需要，动态的为进程分配内存空间。
- 数据结构    
  1. 空闲分区表：在系统中设置一张空闲分区表，记录每个空闲分区的情况。包含分区号、分区大小和分区起始地址等。
  2. 空闲分区链：在每个分区的起始部分设置一些控制分区分配的信息，以及用于连接的前后指针。
- 分配操作    
  1. 分配内存：假设事先规定最小分区大小为size，系统按照某种算法检索空闲分区链，假设检索到的分区大小m_size,系统需要的大小为u_size，若`m_size-u_zize<size`，则将整个分区都分配给请求者，否则从分区中划出u_size大小的空间，余下的部分仍留在空闲分区链中。
  2. 回收内存：先根据需要回收的内存的首地址，从空闲分区链中找到相应的插入点。
     - 回收区与插入点的前一个空闲分区相连，则将回收区和前一个空闲分区合并。
     - 回收区和插入点的后一个空闲分区相连，则将回收区和后一个空闲分区合并，并将回收区的首地址作为新空闲区的首地址，新空闲区的大小为二者之和
     - 回收区同时和插入点的前后空闲区相连，则将三个分区合并，新空闲区的首地址为前一个空闲区的首地址，大小为三个分区大小之和。
     - 回收区和前后空闲区后不相连，则为回收区单独建立一个表项，并插入到空闲链的适当位置。
### 动态分区分配的分配算法
#### 顺序搜索动态分区分配
- 首次适应算法（FF）   
  该算法要求空闲分区链以地址递增进行连接，当需要分配内存时从链首开始查找，直到找到一块大小能够满足的分区为止，再从分区中划分出一块内存进行分配。若找到链尾都没有找到满足的分区，则内存分配失败。
- 循环首次适应算法（NF）    
  与FF算法不同的是，该算法不从链首开始查找，而是从上次查找到的空闲分区的下一个分区开始查找。
- 最佳适应算法（BF）    
  该算法要求将分区按照大小从小到大进行连接，每次从链首开始查找。
- 最坏适应算法（WF）      
  该算法要求分区从大到小进行排列。每次从最大的进行查找。
#### 索引搜索动态分区分配
- 快速适应算法（quick fit）  
  将空闲分区按照大小进行分类，针对每一类分区单独设置分区链。同时维护一个索引表，每个表项对应一种空闲分区链并指向该链的首个分区地址。每次查找分区时只需要找到满足的分区类型的链并取出一块分区。
- 伙伴系统  
  伙伴系统是再内存分配过程中不断将分区分为2的幂次方大小。并针对同样大小的内存分区设置一个分区链。分配内存时首先计算内存大小最少为2的几次幂，假设为2的i次幂，则首先在空闲分区大小为2
  的i次幂的分区中查找，若找不到，则在2的i+1次幂大小的空闲分区链中查找，若找到则，划分出2的i次幂大小的空间，并将剩下的一般放入2的i次幂大小的空闲分区链中。以此类推。
- 哈希算法  
  哈希算法是以空闲分区大小为关键字建立一张哈希表，表中记录了空闲分区链表的头指针。
#### 动态可重定位分区分配
- 紧凑   
  由于连续分配方式会造成内存中有不能被使用的碎片空间，所以需要将内存中的作业进行移动，使作业进行相连，这种操作会造成程序和数据的地址变换，所以必须对程序和数据的地址进行修改。
- 动态重定位   
  在程序进行装入时采用动态运行时装入方式，程序中的地址则均为逻辑地址。在使用时进行地址变换。需要在系统中设置一个重定位寄存器，用来存放程序在内存中的起始位置。当系统对内存进行紧凑时，只需要修改该重定位寄存器，使其指向程序紧凑后的起始地址即可。
- 算法     
  
  ![动态重定位](http://cdn.imkiwi.top/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95.jpg)

## 对换
将内存中暂时不能运行的进程或暂时不用的程序和数据换出到外村上，腾出足够的空间使得已具备运行条件的进程或进程所需的程序和数据能够被调入内存。以改善内存的利用率和系统的吞吐量。
### 对换类型
- 整体对换：处理机调度中的中级调度，即以整个进程为单位进行换入和换出。
- 页面对换：以进程的页面或分段为单位进行换入和换出，时段页时存储的基础。
### 进程对换
- 进程的换出   
  1. 选择被换出的进程。首先检索处于阻塞状态或睡眠状态的进程，再从这些进程中选择优先级最低的进程作为换出的进程。若没有阻塞或睡眠的进程，则选择优先级最低的进程进行换出。
  2. 进程换出时只能换出非共享的程序和数据段。对于共享的程序和数据段则在没有进程使用时才能够进行换出。进程换出时先申请兑换空间，若申请成功则启动磁盘，再将该进程的程序和数据写入磁盘的对换区上。若写入过程没有出现错误，则回收该进程使用的内存空间并修改该进程的PCB和相应的内存分配表等数据。进程的换出持续到系统中再无阻塞进程为止。
- 进程的换入   
  首先查看PCB中的所有进程状态，检索所有已就绪并且换出的进程，从中选择换出时间最久并大于系统规定的最小时间的进程。为该进程申请内存，如果申请成功则将进程从外村调度内存，若申请失败，则将内存中的进程换出并腾出足够的空间。成功换入一个进程后继续执行换入换出的过程，陆续将就绪且换出的进程全部换入内存。直到没有已换出的进程或没有足够的内存。  
## 分页存储管理
### 基础
- 页面和物理快    
  1. 分页存储管理将进程的逻辑地址空间分成若干个页，并为页面从0开始加以编号。同时将内存的物理地址分成若干个块，也为这些块夹以编号。在为进程分配内存空间时，以块为单位将进程中的若干个页分别装入多个物理上可以不相邻的块中。
  2. 页面选择过小会造成进程的页面过多，进程的页表过大。导致页表占用大量内存并使得进程的换入换出效率变低。页面选择过大会造成最后一页不能被利用的碎片变大。
- 地址结构   
  分页地址中的地址结构分为两部分，前一部分为页号，后一部分为位移量。由于进程的各个页离散的分布在内存的物理块中，所以需要维护一张表记录页面与物理块的映射关系。这张表称位页表。同时，该页表可以维护一些存续控制信息，例如只读等。
### 地址变换
由于需要将用户地址空间中的逻辑地址转换为实际的物理地址，所有需要设置地址变换机构，以完成逻辑地址到物理地址的转换。由于页面和物理块的大小是相同的，所以页内的偏移量和块内的偏移量相等。地址变换只需要将页号转换为块号即可。
#### 基本结构
当进程在处理机中运行时，系统将PCB中的页表首地址和页表长度装入寄存器中，地址变换时首先将页号与页表长度进行比较，如果页号大于页表长度，则产生一次越界中断。若无错误，则在页表中检索该页所对应的物理块号，再将物理块号和页内偏移量进行组合，得到物理地址。
#### 快表
快表是指在计算机中设置一个具有并行查询能力的高速缓冲寄存器。该寄存器的访问速度远快于内存。当系统需要执行地址变换时，首先在该寄存器中检索页号所对应的物理块号，若找不到，则再从内存中查找。并将找到的结果放入寄存器中，若寄存器中没有空闲的位置，则根据某种算法选择一个页表项进行覆盖。
### 访问内存的有效时间
- 访问内存的时间：t
- 快表的命中率：a
- 快表的检索时间：m
```
没有快表：2*t
有快表：a*m+(t+m)(1-a)+t = 2*t+m-t*a
```
### 多级页表
由于页表可能占用的内存很大，使用连续的内存存储完整的页表很难做到。所以需要维护多级页表。上一级页表中的物理块中存储了下一级的页表。
### 反置页表
反置页表是为每一个物理块设置一个页表项，其中维护了该物理块对应的页号和所属的进程。
## 分段存储管理
由于程序通常可以分为若干个段，每个段是一个相对独立的逻辑单位。同时为了满足信息共享、保护等功能，引入了分段存储管理。
### 作用
- 方便编程
- 信息共享
- 信息保护
- 动态增长
- 动态链接
### 原理
- 分段    
  分段存储管理中，作业的地址空间被划分为多个段。分段地址中的结构为段号加段内地址。
- 段表     
  一张维护了段号以及该段的段长和内存中起始地址的表
- 地址变换   
  首先判断段号是否超过段表的长度，超过则为访问越界。再判断段内地址是否超过段长，超过则产生越界中断。最后将该段的起始地址和段内地址相加则为实际的物理地址。
### 分段和分页的区别
- 页是信息的物理单位。目的是消除内存的外零头，提高内存的利用率。
- 页的大小由系统界定，是固定的。段的大小由用户确定。
- 分页的用户程序地址空间是一维的，分段则为二维。
## 段页式存储管理
### 基本原理
首先将用户程序分为若干个段，再将每个段分为若干个页，并为每个段赋予一个段名。其中，段表中维护的是该段的页表的起始地址和页表长度。
### 地址变换
首先从内存中获取该段再段表中的位置以及所对应的页表的起始位置，再从页表中查找到实际的物理地址。一共需要三次访问内存。第一次为从内存中查找段表，第二次为查找该段的页表，第三次是从获取的物理地址中得到需要的数据。