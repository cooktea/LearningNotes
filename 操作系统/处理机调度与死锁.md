# 处理机调度与死锁
![框架](http://cdn.imkiwi.top/image/markdown/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E5%92%8C%E6%AD%BB%E9%94%81.png)

- [处理机调度与死锁](#%e5%a4%84%e7%90%86%e6%9c%ba%e8%b0%83%e5%ba%a6%e4%b8%8e%e6%ad%bb%e9%94%81)
  - [基础](#%e5%9f%ba%e7%a1%80)
    - [处理价调度层次](#%e5%a4%84%e7%90%86%e4%bb%b7%e8%b0%83%e5%ba%a6%e5%b1%82%e6%ac%a1)
    - [目标](#%e7%9b%ae%e6%a0%87)
      - [共同目标](#%e5%85%b1%e5%90%8c%e7%9b%ae%e6%a0%87)
      - [不同操作系统的调度目标](#%e4%b8%8d%e5%90%8c%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e8%b0%83%e5%ba%a6%e7%9b%ae%e6%a0%87)
  - [作业调度](#%e4%bd%9c%e4%b8%9a%e8%b0%83%e5%ba%a6)
    - [作业](#%e4%bd%9c%e4%b8%9a)
      - [作业控制块（JCB）](#%e4%bd%9c%e4%b8%9a%e6%8e%a7%e5%88%b6%e5%9d%97jcb)
      - [状态和阶段](#%e7%8a%b6%e6%80%81%e5%92%8c%e9%98%b6%e6%ae%b5)
    - [调度算法](#%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95)
  - [进程调度](#%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6)
    - [基础](#%e5%9f%ba%e7%a1%80-1)
    - [调度算法](#%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95-1)
      - [轮转调度（RR）](#%e8%bd%ae%e8%bd%ac%e8%b0%83%e5%ba%a6rr)
        - [进程切换时机](#%e8%bf%9b%e7%a8%8b%e5%88%87%e6%8d%a2%e6%97%b6%e6%9c%ba)
      - [优先级调度](#%e4%bc%98%e5%85%88%e7%ba%a7%e8%b0%83%e5%ba%a6)
      - [多队列调度](#%e5%a4%9a%e9%98%9f%e5%88%97%e8%b0%83%e5%ba%a6)
      - [多级反馈队列](#%e5%a4%9a%e7%ba%a7%e5%8f%8d%e9%a6%88%e9%98%9f%e5%88%97)
      - [公平调度](#%e5%85%ac%e5%b9%b3%e8%b0%83%e5%ba%a6)
  - [死锁](#%e6%ad%bb%e9%94%81)
    - [概述](#%e6%a6%82%e8%bf%b0)
      - [资源](#%e8%b5%84%e6%ba%90)
      - [死锁的原因](#%e6%ad%bb%e9%94%81%e7%9a%84%e5%8e%9f%e5%9b%a0)
      - [死锁的必要条件](#%e6%ad%bb%e9%94%81%e7%9a%84%e5%bf%85%e8%a6%81%e6%9d%a1%e4%bb%b6)
      - [思索地处理方法](#%e6%80%9d%e7%b4%a2%e5%9c%b0%e5%a4%84%e7%90%86%e6%96%b9%e6%b3%95)
    - [预防死锁](#%e9%a2%84%e9%98%b2%e6%ad%bb%e9%94%81)
    - [避免死锁](#%e9%81%bf%e5%85%8d%e6%ad%bb%e9%94%81)
      - [系统的安全状态](#%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%ae%89%e5%85%a8%e7%8a%b6%e6%80%81)
      - [银行家算法](#%e9%93%b6%e8%a1%8c%e5%ae%b6%e7%ae%97%e6%b3%95)
    - [死锁检测](#%e6%ad%bb%e9%94%81%e6%a3%80%e6%b5%8b)
    - [死锁解除](#%e6%ad%bb%e9%94%81%e8%a7%a3%e9%99%a4)

## 基础
### 处理价调度层次
1. 高级调度：长程调度或作业调度。调度对象是作业。根据调度算法选择作业将其从外存调入内存，并创建进程和分配资源。
2. 中级调度：有成内存调度，主要作用是提高内存利用率和系统吞吐量。将暂时不能运行的进程调至外存等待。
3. 低级调度：调度对象是进程或内核级线程。根据调度算法决定就绪队列中的哪个进程获得处理机。
### 目标
#### 共同目标
1. 提高系统的资源利用率，使系统中的处理机和其他资源都尽可能保持忙碌状态。
2. 公平，使系统中的进程都能获得合理的cpu时间，不会出现进程长时间无法获得cpu的情况。
3. 平衡，由于有不同类型的进程（计算型、I/O型），调度算法应经可能保持系统资源使用的平衡性。
4. 策略强制执行，对于调度算法指定的策列应准确执行。
#### 不同操作系统的调度目标
- 批处理系统
  1. 平均周转时间短
  2. 系统吞吐量高
  3. 处理机利用率高
- 分时系统
  1. 响应时间快
  2. 均衡
- 实时系统
  1. 保证截至时间
  2. 可预测

## 作业调度
### 作业
#### 作业控制块（JCB）
作业控制块由“作业注册”程序在作业进入系统时为该作业建立。JCB主要包含作业标识、用户名称、用户账号、作业类型、作业状态、调度信息、资源需求、资源使用情况等。  
#### 状态和阶段
1. 收容阶段（后备状态）：作业被输入到硬盘上，建立了JCB并放入后备队列中。
2. 运行阶段（运行状态）：作业被调度选中后，分配了必要的资源和建立进程，并放入就绪队列。从第一次进入就绪状态直达票运行结束都是运行阶段。
3. 完成阶段（完成状态）：作业运行完成或异常结束。
### 调度算法
1. 先来先服务（FCFS）：作业按照进入就绪队列的顺序进行调度。先进入就绪队列的作业先被调度。
2. 短作业优先（SJF）：选择预估执行时间最短的几个作业优先调度进入内存运行。
3. 优先级调度（PSA）：基于作业的紧迫程度进行调度，由外部赋予作业相应的优先级。优先级高的作业优先进入内存运行。
4. 高响应比优先（HRRN）：FCFS和SJF只考虑了作业的等待时间和执行时间，不能兼顾。高相应比优先调度为每个作业计算优先权。   
   `优先权=（等待时间+要求服务时间）/要求服务时间`
## 进程调度
### 基础
- 进程调度的任务
  1. 保存处理机的现场信息
  2. 按某种算法选择进程
  3. 把处理器分配给进程
- 进程调度的机制
  1. 排队器：排队器将就绪进程插入到就绪队列中
  2. 分派器：分派器按照进程调度程序选择的结果将进程抽出就绪队列。并进行从分派器到进程之间的上下文切换。
  3. 上下文切换器：进程切换时会进行两次上下文切换，第一次是当前运行进程和分派器程序之间的上下文切换，第二次是分派器程序和新进程之间的上下文切换。
- 进程调度方式
  1. 非抢占式：进程一旦拥有处理机后除非进程执行完成或阻塞，不会有其他进程抢占处理机资源。
  2. 抢占式：允许调度程序根据某种原则暂停正在执行的进程，并将处理机分配给别的进程。
### 调度算法
#### 轮转调度（RR）
轮转调度是根据FCFS策略将所有的就绪进程在系统中排成一个就绪队列，并每隔一段时间产生一次中断，激活进程调度程序完成一次进程调度。
##### 进程切换时机
1. 若一个进程运行完成，但时间片未用完，应立即启动调度程序。
2. 时间片用完但进程尚未结束，将进程插入就绪队列的末尾。
#### 优先级调度
- 静态优先级：在进程创建时确定，整个运行期间保持不变。    
  选择优先级大小的依据：   
  1. 进程类型，系统进程的优先级高于用户进程
  2. 资源需求，资源需求小的进程优先级更高
  3. 用户要求。
- 动态优先级：动态优先级是在进程创建时先赋予一个初始优先级，该优先级在进程的运行过程中会改变，以获得更好的调度性能。
#### 多队列调度
多级队列将系统中的就绪队列拆分为多个就绪队列，不同的就绪队列可以采用不同的调度算法。
#### 多级反馈队列
多级反馈调度算法在系统中设置多个就绪队列，并为每个队列设置不同的优先级。第一个队列的优先级最高，最后一个队列的优先级最低。且不同就绪队列中的进程所获得的时间片的大小也不同，优先级越高的队列时间片越小。    
每个队列都采用FCFS算法，当新进程进入内存后，将其放入第一个就绪队列的队尾，如果在第一个时间片中未完成，则放入第二个就绪队列的末尾。以此类推。   
系统按就绪队列的优先级进行调度，只有前面所有的就绪队列都空闲，才能调度后面的就绪队列。当某优先级较低的队列中的进程正在执行时，高优先级队列中出现了就绪进程，则将正在执行的进程放入当前队列的末尾，并调度新出现的进程运行。
![多级反馈队列](http://pxjspaae8.bkt.clouddn.com/1568446605.558721.jpg)
#### 公平调度
1. 保证调度算法   
2. 公平分享调度算法
## 死锁
### 概述
#### 资源
- 可重用资源：可以供用户重复使用的资源。   
  性质：  
  1. 每一个可重用资源中的单元只能分配给一个进程使用，不允许多个进程共享
  2. 进程使用资源的顺序：请求资源->使用资源->释放资源
  3. 可重用资源是固定的，进程在运行中不能创建也不能删除可重用资源。  
- 可消耗资源：进程在运行期间，动态地创建和消耗的资源。    
  性质：   
  1. 数量在运行期间不断变化
  2. 进程运行过程中可以不断地创造资源，并将资源放入该类资源的缓冲区中。
  3. 进程在运行过程中可以请求若干个资源，并不再释放。
- 可抢占资源：进程获得该类资源后可能被别的进程或系统抢占。该类资源不会引起死锁。
- 不可抢占资源：该类资源一旦被分配给进程，则不允许中途进行回收。只能等拥有该资源的进程释放资源。
#### 死锁的原因
- 竞争不可抢占资源   
- 竞争可消耗资源
- 进程推进顺序不当
#### 死锁的必要条件
- 互斥条件：进程请求只能被互斥使用的资源
- 请求和保持条件：进程已经获得了一个资源，又申请了一个已经被别的进程占有的资源，同时对于已经获得的资源不进行释放。
- 不可抢占条件：进程已获得的资源在使用完成之前不能被抢占。
- 循环等待条件：死锁发生时，必然存在一个资源--进程的循环链。
#### 思索地处理方法
1. 预防死锁
2. 避免死锁
3. 检测死锁
4. 解除死锁
### 预防死锁
- 破坏请求和保持条件：当进程请求资源是，进程不能持有不可抢占资源。    
  1. 进程在获取资源时必须一次性获取所有资源
  2. 进程在获取新资源时，必须将已经使用完成的全部资源进行释放。
- 破坏不可抢占条件：当一个拥有不可抢占资源的进程在申请资源但不能被满足时，必须释放已经持有的全部资源。
- 破坏循环等待条件：对系统中的所有资源编号并进行线性排序，进程在申请资源时必须按照序号顺序进行申请，即必须先申请校序号的资源，成功后才能申请大序号的资源。当同一种资源的需求不止一个时，必须一次性申请全部。
### 避免死锁
#### 系统的安全状态
系统能够按照某种进程的推进顺序为每个进程分配资源，直至每个进程都获得其对资源的最大需求，使得每个进程都可以顺利推进。  
#### 银行家算法
- 数据结构：   
  1. 可利用资源向量Available，是一个大小为m的数组，其中`Available[i]=K`表示第i个资源的可分配数量为K。
  2. 最大需求矩阵Max，是一个大小为n x m的矩阵。代表系统中的n个进程对m个资源的最大需求。即`Max[i][j] = K`为第i个进程对第j个资源的最大需求为K。
  3. 分配矩阵Allocation，是一个大小为n x m的矩阵，定义了系统中每一类资源分配给每一个进程的资源数。即`Allocation[i][j] = K`表示进程i已经分配了K个j资源。
  4. 需求矩阵Need，是一个n x m的矩阵，定义了每一个进程尚且需要的各类资源数量。即`Need[i][j] = K`表示进程i还需要K个j资源。
   ```
   Need[i][j] = Max[i][j] - Allocation[i][j]
   ```
- 算法：
  1. 假设进程i的资源需求向量为Request。
  2. 如果Request[j] <= Need[i][j],则进入第三步，否则出错。因为该进程所需要的资源超过了其宣布的最大值。
  3. 如果Request[j] <= Available[j]，则进入第四步，否则进程需要等待，因为可分配的资源不足。
  4. 系统假设将资源分配给进程，并修改相关如下数据：   
     ```
     Available[j] = Available[j]-Reuqest[j];
     Allocation[i][j] = Allocation[i][j]+Request[j]
     Need[i][j] = Need[i][j]-Request[j]
     ```
  5. 系统执行安全性算法，检查此次分配后系统是否处于安全状态，若分配后系统处于安全状态，则执行此次分配，若不安全，则让进程等待，并将上述的修改回滚。 
- 安全性算法：
  1. 设置两个向量，分别为工作向量Work，表示系统可以提供给进程各类型资源的数量，初始时该向量等于Available。第二个为Finish，表示是否有足够的资源分配给进程，初始为false。
  2. 从进程集合中找到一个满足下述条件的进程i：    
     - Finish=false
     - Need[i][j] <= Work[j]
  3. 如果找到，则修改下列数据：   
     ```
     Work[j] = Work[j]+Allocation[i][j]
     Finish[i] = true
     ```
     返回第二步
  4. 若找不到，当系统中所有进程都满足Finish=true，则系统处于安全状态，否则处于不安全状态。
### 死锁检测
### 死锁解除