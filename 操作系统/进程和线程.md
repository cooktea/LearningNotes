# 进程和线程
![框架](http://cdn.imkiwi.top/image/markdown/%E8%BF%9B%E7%A8%8B.png)
- [进程和线程](#%e8%bf%9b%e7%a8%8b%e5%92%8c%e7%ba%bf%e7%a8%8b)
  - [进程的定义](#%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%ae%9a%e4%b9%89)
  - [进程的状态](#%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81)
    - [三态图](#%e4%b8%89%e6%80%81%e5%9b%be)
    - [五态图](#%e4%ba%94%e6%80%81%e5%9b%be)
    - [进程挂起](#%e8%bf%9b%e7%a8%8b%e6%8c%82%e8%b5%b7)
      - [引入挂起后进程的状态转换](#%e5%bc%95%e5%85%a5%e6%8c%82%e8%b5%b7%e5%90%8e%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2)
  - [PCB的结构和作用](#pcb%e7%9a%84%e7%bb%93%e6%9e%84%e5%92%8c%e4%bd%9c%e7%94%a8)
    - [结构](#%e7%bb%93%e6%9e%84)
    - [作用](#%e4%bd%9c%e7%94%a8)
  - [进程控制](#%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6)
    - [创建](#%e5%88%9b%e5%bb%ba)
      - [创建的原因](#%e5%88%9b%e5%bb%ba%e7%9a%84%e5%8e%9f%e5%9b%a0)
      - [创建的过程](#%e5%88%9b%e5%bb%ba%e7%9a%84%e8%bf%87%e7%a8%8b)
    - [终止](#%e7%bb%88%e6%ad%a2)
      - [终止的原因](#%e7%bb%88%e6%ad%a2%e7%9a%84%e5%8e%9f%e5%9b%a0)
      - [终止的过程](#%e7%bb%88%e6%ad%a2%e7%9a%84%e8%bf%87%e7%a8%8b)
    - [阻塞与唤醒](#%e9%98%bb%e5%a1%9e%e4%b8%8e%e5%94%a4%e9%86%92)
      - [原因](#%e5%8e%9f%e5%9b%a0)
      - [阻塞过程](#%e9%98%bb%e5%a1%9e%e8%bf%87%e7%a8%8b)
      - [唤醒过程](#%e5%94%a4%e9%86%92%e8%bf%87%e7%a8%8b)
    - [挂起与激活](#%e6%8c%82%e8%b5%b7%e4%b8%8e%e6%bf%80%e6%b4%bb)
      - [挂起](#%e6%8c%82%e8%b5%b7)
      - [激活](#%e6%bf%80%e6%b4%bb)
  - [进程同步](#%e8%bf%9b%e7%a8%8b%e5%90%8c%e6%ad%a5)
    - [基本概念](#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5)
    - [硬件同步](#%e7%a1%ac%e4%bb%b6%e5%90%8c%e6%ad%a5)
    - [信号量](#%e4%bf%a1%e5%8f%b7%e9%87%8f)
      - [整形信号量](#%e6%95%b4%e5%bd%a2%e4%bf%a1%e5%8f%b7%e9%87%8f)
      - [记录型信号量](#%e8%ae%b0%e5%bd%95%e5%9e%8b%e4%bf%a1%e5%8f%b7%e9%87%8f)
      - [AND型信号量](#and%e5%9e%8b%e4%bf%a1%e5%8f%b7%e9%87%8f)
      - [信号量集](#%e4%bf%a1%e5%8f%b7%e9%87%8f%e9%9b%86)
      - [信号量应用](#%e4%bf%a1%e5%8f%b7%e9%87%8f%e5%ba%94%e7%94%a8)
    - [管程](#%e7%ae%a1%e7%a8%8b)
      - [定义](#%e5%ae%9a%e4%b9%89)
      - [结构](#%e7%bb%93%e6%9e%84-1)
    - [经典问题](#%e7%bb%8f%e5%85%b8%e9%97%ae%e9%a2%98)
  - [进程通信](#%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1)
    - [类型](#%e7%b1%bb%e5%9e%8b)
      - [共享存储器系统](#%e5%85%b1%e4%ba%ab%e5%ad%98%e5%82%a8%e5%99%a8%e7%b3%bb%e7%bb%9f)
      - [管道（pipe）](#%e7%ae%a1%e9%81%93pipe)
      - [消息传递](#%e6%b6%88%e6%81%af%e4%bc%a0%e9%80%92)
      - [CS模型](#cs%e6%a8%a1%e5%9e%8b)
  - [线程](#%e7%ba%bf%e7%a8%8b)
    - [线程和进程的比较](#%e7%ba%bf%e7%a8%8b%e5%92%8c%e8%bf%9b%e7%a8%8b%e7%9a%84%e6%af%94%e8%be%83)
    - [线程的实现方式](#%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f)
      - [内核支持线程](#%e5%86%85%e6%a0%b8%e6%94%af%e6%8c%81%e7%ba%bf%e7%a8%8b)
      - [用户级线程](#%e7%94%a8%e6%88%b7%e7%ba%a7%e7%ba%bf%e7%a8%8b)
      - [组合方式](#%e7%bb%84%e5%90%88%e6%96%b9%e5%bc%8f)

## 进程的定义
进程实体：由程序段、相关数据段、PCB构成  
>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

>进程是程序的一次执行。  

>进程是程序及其数据在处理机上顺序执行时所发生的活动。  

>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。
## 进程的状态
### 三态图
- 就绪状态：进程已经处于准备运行的状态，分配了除cpu以外的所有资源。系统中所有处于就绪状态的进程按照一定策略形成一个就绪队列。
- 执行状态：进程已获得cpu，正在运行。
- 阻塞状态：正在执行的进程由于某些原因（I/O请求等）暂时无法执行。操作系统将处理机分配给另一个就绪进程，无法执行的进程将处于暂停状态，并加入阻塞队列。按照不同的阻塞原因，系统中可能有多个阻塞队列。  

![三态图及其转换](http://cdn.imkiwi.top/image/markdown/1568254890.1381.jpg)
### 五态图
除上述三种状态外，还有另外两种状态被引入用来满足进程控制块对数据及操作的完成性要求和增强管理的灵活性。分别为创建状态和终止状态。
- 创建状态：进程在创建时需要经过很多个步骤，如申请空白PCB并填写PCB信息、分配运行时需要的资源、将进程转为就绪态并插入就绪队列等。在这一系列步骤的执行过程中，进程处于创建状态。
- 终止状态：进程终止时需要两个步骤，分别是等待操作系统用善后和回收PCB。进程到达终止状态后不能运行，但仍在操作系统中保存一个记录，供别的进程收集。   

![五态图及其转换](http://cdn.imkiwi.top/image/markdown/1568255158.596917.jpg)
### 进程挂起
为了系统和用户观察、分析进程的需要，引入了挂起操作。进程在执行中被挂起则暂停执行、若是就绪态的进程被挂起则暂时不接受调度。
#### 引入挂起后进程的状态转换
- 活动就绪（Readya）-->(Suspend)-->静止就绪（Readys）：就绪进程可调度-->就绪进程不可调度。
- 活动阻塞（Blockeda）-->(Suspend)-->静止阻塞（Blockeds）：当静止阻塞的进程达到就绪条件后转为静止就绪。
- 静止就绪-->(Active)-->活动就绪：就绪进程不可调度-->就绪进程可调度。
- 静止阻塞-->(Active)-->活动阻塞：

![有挂起状态的三态图](http://cdn.imkiwi.top/image/markdown/1568255607.990113.jpg)
![有挂起状态的五态图](http://cdn.imkiwi.top/image/markdown/1568255751.003329.jpg)
## PCB的结构和作用
### 结构
- 进程标识符  
  用来唯一的标识一个进程
  - 外部标识符：由进程创建者提供，方便用户的访问。
  - 内部标识符：OS创建，方便系统对进程的使用。
- 处理机状态：  
  1. 通用寄存器
  2. 指令计数器
  3. 程序状态字PSW
  4. 用户栈指针
- 进程调度信息：  
  1. 进程状态
  2. 进程优先级
  3. 进程调度需要的信息
  4. 时间（阻塞原因）
- 进程控制信息：
  1. 程序和数据的地址
  2. 进程同步和通信机制
  3. 资源清单
  4. 链接指针（下一个进程PCB的首地址）
### 作用
1. 作为独立运行基本单位的标志
2. 能实现间断性运行方式
3. 提供进程管理所需要的信息
4. 提供进程调度所需要的信息
5. 实现与其他进程的同步与通信
## 进程控制
### 创建
#### 创建的原因
1. 用户登录
2. 作业调度
3. 提供服务
4. 应用请求
#### 创建的过程
1. 申请空白PCB，获得唯一的数字标识符，并从PCB集合中索取一个空白PCB
2. 为进程分配其所悟要的各种物理和逻辑资源。从操作系统或父进程获得。
3. 初始化PCB：  
    1. 初始化标识信息
    2. 初始化处理机状态信息
    3. 初始化处理机控制信息
4. 如果就绪队列允许，则将进程插入就绪队列
### 终止
#### 终止的原因
1. 正常结束
2. 一场结束
3. 外界干预
#### 终止的过程
1. 根据进程标识符检索PCB，读取进程状态
2. 若为执行状态，立即终止进程的执行，并置调度标志为真。
3. 若由子孙进程，则将其所有子孙进程终止
4. 将被终止的进程拥有的所有资源都归还给父进程和操作系统
5. 将该进程的PCB从队列中移除
### 阻塞与唤醒
#### 原因
1. 向系统请求共享资源失败
2. 等待某种操作完成
3. 新数据尚未到达
4. 等待新任务的到达
#### 阻塞过程
进程自己调用block原语阻塞自身。若进程处于执行状态，则先停止执行，将进程状态由“执行”改为“阻塞”，并将PCB插入对应的阻塞队列。调度程序重新发起调度，选择就绪队列中的就绪进程，并进行进程切换。
#### 唤醒过程
当被阻塞的进程等待的事件发生，由别的进程调用wakeup原语唤醒被阻塞的进程。将被阻塞的进程从阻塞队列中移除，并将PCB中的进程状态改为“就绪”，并插入就绪队列。

### 挂起与激活
#### 挂起
操作系统调用Suspend原语将进程挂起。首先检查进程的状态，若处于活动就绪，则将其改为静止就绪。若处于活动阻塞，则改为静止阻塞。若进程正在执行，则重新进行进程调度。
#### 激活
操作系统调用active原语激活进程。首先将进程从外存调入内存，并检查该进程的状态，若为静止就绪，则改为活动就绪，若为静止阻塞，则改为活动阻塞。若调度方式为抢占式调度，则进程被改为活动就绪后应检查是否需要重新进行进程调度。若被激活的进程优先级大于正在执行的进程，则将处理机分配给被激活的进程。
## 进程同步
### 基本概念
- 临界资源：进程间应采取互斥访问的方式访问的资源
- 临界区：代码中需要使用临界资源的部分
- 同步机制原则：  
  1. 空闲让进
  2. 忙则等待
  3. 有限等待
  4. 让权等待
### 硬件同步
1. 关中断  
   在进行锁测试之前关闭中断，以此使得在进行锁测试时不会发生进程调度。
2. Test-And-Set   
   利用原子操作TS获取锁的状态。
   ```
   boolean TS(boolean *lock){
       boolean old = *lock;
       *lock = true;
       return old;
   }
   ```
3. Swap   
   利用原子操作swap交换锁和一个为true的变量。通常有硬件交换指令。
   ```
   void swap(boolean *a,boolean *b){
       boolean temp = *a;
       *a = *b;
       *b = temp;
   }

    do{
        key = true;
        do{
            swap(&lock,&key);   //交换锁和key的值
        } while(key != true)    //直到锁为false
        ....
        临界区
        ....
        lock = false;           //临界区结束，将锁置为false
        ....
    } while(true)
   ```
### 信号量
#### 整形信号量
定义了一个表示资源数目的整形量S，且S只能通过原则操作wait(S)和signal(S)进行操作。
```
wait(S){
  while(S<=0){
    do nothing  //空循环
  }
  S--;
}

signal(S){
  S++;
}
```
#### 记录型信号量
整型信号量由于wait中存在空循环，会大量浪费cpu时间，所以未遵循“让权等待”准则。记录型信号量则不会存在“忙等”。该信号量除了维护资源的数量外，还维护了由于等待该资源而阻塞的进程队列。当进程等待该资源时，进入该队列并让出cpu，当有进程释放资源时，唤醒该队列中的某个阻塞进程。
```
struct seamphore{
  int value //资源数量
  struct blocked_process_list *list;  //阻塞队列
}

wait(seamphore *S){
  S->value --; //申请资源
  if(S->value < 0){ //申请后资源小于0，即未申请到资源
    block(S->list)  //将进程加入该资源的阻塞队列
  }
}

signal(seamphore *S){
  S->value++;
  if(S->value <= 0){  //仍有进程在等待该资源
    wakeup(S-<list) //唤醒阻塞队列中的一个进程
  }
}
```
#### AND型信号量
由于进程有时不止需要一个资源，记录型信号量不能满足这种需要使用两个或两个以上的资源的情况。此使可以使用AND型信号量。  
AND型信号量是当所有资源均满足时才允许进程进入临界区。
```
Swait(S1,S2,...,Sn){
  while(true){
    if(S1>=1 && S2>=1 && ... && Sn>=1){
      for(int i=0;i<n;i++>){
        Si --;
      }
    } else {
      将进程放入第一个S<=1的资源的阻塞队列中。
    }
  }
}

Ssignal(S1,S2,...,Sn){
  while(true){
      for(int i=0;i<n;i++>){
        Si ++;
        移除所有Si中阻塞队列里的进程，并添加进就绪队列中。
      }
  }
}
```
#### 信号量集
前述的信号量只能每次对资源进行加一或减一的操作。而进程有时候对同一个资源不止申请一个，所以需要引入信号量集。   
信号量集是对AND型信号量的扩充，其对Si信号量的测试值不再是1，而是该资源的分配下限值ti，即需要Si->value >= ti,否则不允许分配。进程对该资源的需求为di。
```
Swait(S1,t1,d1,S2,t2,d2,...,Sn,tn,dn){

}

Ssignal(S1,t1,d1,S2,t2,d2,...,Sn,tn,dn){

}
```
- Swait(S,1,0):开关信号量。当S>=1时，允许多个进程进入某特定区，若S=0，则阻止任何进程进入某特定区。

#### 信号量应用
1. 使用信号量实现进程互斥
   ```
   seamphore mutex = 1;

    Process1(){
      while(true){
        wait(mutex);
        临界区
        signal(mutex);
        剩余区
      }
    }

    Process2(){
      while(true){
        wait(mutex);
        临界区
        signal(mutex);
        剩余区
      }
    }
   ```
2. 利用信号量实现前驱关系  
   前驱进程在执行过程中signal后继进程需要使用的信号量。后继进程在执行前使用wait。
   ```
      代码略  
   ```
### 管程
#### 定义
> 一个管程定义了一个数据结构和能为并发进程所执行的一组操作
#### 结构
1. 管程的名称
2. 局部于管程的共享数据结构说明
3. 对该数据结构进行操作的一组过程
4. 对局部于管程的共享数据设置初始值的语句
### 经典问题
1. 生产者-消费者   
   ```
   //信号量解法
   in
   int n=0,out=0; 
   item buffer[n] //大小为n的仓库
   seamphore mutex = 1,empty = 0,full = n;
   
   void producer(){
     while(true){
       goods = getgoods();  //生产一个产品
       wait(empty);
       wait(mutex);
       buffer[in] = goods;  //将产品放入仓库
       in = (in+1)%n;
       signal(mutex);
       signal(full);
     }
   }

   void consumer(){
     while(true){
       wait(full);
       wait(mutex);
       goods = buffer[out];
       out = (out+1)%n
       signal(mutex);
       signal(empty);
     }
   }

   void main(){
     producer();
     consumer();
   }
   ```
2. 哲学家进餐
   ```
   //AND型信号量解法
   int n; //哲学家数量
   seamphore chopstick[n] = {1};
   while(true){
     Swait(chopstick[(i+1)%n],chopstick[i]);
     Eat...
     Ssignal(chopstick[(i+1)%n],chopstick[i]);
   }
   ```
3. 读-写
   ```
   //信号量集
   int RN;  //读者数量限制
   seamphore L = RN,mutex = 1;
   void Reader(){
     while(true){
       Swait(L,1,1);
       Swait(mx,1,0); //等待无人写
       ...
       read
       ...
       Ssignal(L,1);
     }

    void Writer(){
      while(true){
        Swait(mx,1,1,L,RN,0); //等待所有读者退出
        ...
        write
        ...
        Ssignal(mx,1);
      }
    }
   }
   ```
## 进程通信
### 类型
#### 共享存储器系统
1. 基于共享数据结构  
   公用某些数据结构，实现进程间的数据共享和信息交换
2. 基于共享存储区   
   传输大量数据时在内存中划分一块共享区域供进程间交换信息使用
#### 管道（pipe）
管道是连接一个读进程和写进程的文件。进程间使用字符流的形式传递信息。  
管道必须提供三方面的协调能力：   
1. 互斥
2. 同步
3. 确认对方是否存在
#### 消息传递
消息传递不需要使用共享存储区，而是以格式化的消息为范围，将数据封装在消息中并通过操作系统提供的通信命令传递消息。
#### CS模型
1. 套接字
2. 远程过程调用和远程方法调用
## 线程
### 线程和进程的比较
1. 调度方面：在引入线程的操作系统中，线程是调度和分派的基本单位，是能独立运行的基本单位。
2. 并发性：进程间可以并发执行，且一个进程中的多个线程也能并发执行。
3. 资源：进程可以拥有资源，且是系统中拥有资源的基本单位。线程本身并不拥有系统资源，仅有一点必不可少的资源，如TCB和程序计数器等少数寄存器。线程间还允许共享进程的资源。
4. 独立性：进程的独立性高，线程的独立性低。除了全局变量外，进程不允许访问别的进程的资源。但同一个进程的的多个线程可以互相访问资源。
5. 系统开销：由于涉及上下文切换，继承的切换代价远高于线程。进程的创建和销毁需要的系统开销均大于线程。
6. 支持多处理机系统：一个进程只能运行在一个处理机上，所以不论处理机的数量有几个，单线程进程只能使用一个处理机。但一个进程的多个线程可以分散在多个处理及上运行。
### 线程的实现方式
#### 内核支持线程
线程的创建、阻塞、撤销、切换均在内核空间完成。内裤和空间中为每个内核线程设置了线程控制块。   
优点：  
1. 多处理机系统中，内核能够同时调度统一进程中的多个线程并行执行。
2. 如果进程中的一个线程阻塞，内核可以调度别的线程占有处理机。
3. 内核线程具有很小的数据结构和堆栈，切换较快。
4. 内核本身可以使用多线程技术，提高系统的执行速度和效率。
#### 用户级线程
用户级线程在用户空间中实现，与内核无关。用户级线程在调度时仍以进程为单位。   
优点：  
1. 线程切换不需要转换到内核空间，节省了模式切换的开销。
2. 调度算法可以是进程专用的，可以根据自身情况选择调度算法。
3. 用户级线程的实现和操作系统无关，可以在不支持线程的操作系统中实现线程。   

缺点：   
1. 当进程中的一个线程被阻塞时，进程中的所有线程都会被阻塞
2. 进程中的所有线程只能在同一个处理机中运行
#### 组合方式
将用户级线程映射到内核线程（一对一，多对一，多对多）
